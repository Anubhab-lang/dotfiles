'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
const VSCode = require("vscode");
const Path = require("path");
const FS = require("fs");
const PortFinder = require("portfinder");
const Net = require("net");
const ChildProcess = require("child_process");
const vscode_languageclient_1 = require("vscode-languageclient");
const vscode_1 = require("vscode");
const vscode_jsonrpc_1 = require("vscode-jsonrpc");
const P2C = require("vscode-languageclient/lib/protocolConverter");
let p2c = P2C.createConverter();
PortFinder.basePort = 45556;
const DEBUG_ARG = '-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=y';
function activate(options, context) {
    let DEBUG = options.DEBUG;
    let jvmHeap = options.jvmHeap;
    if (options.CONNECT_TO_LS) {
        return connectToLS(context, options);
    }
    else {
        let clientOptions = options.clientOptions;
        let fatJarFile = Path.resolve(context.extensionPath, options.fatJarFile);
        var log_output = VSCode.window.createOutputChannel(options.extensionId + "-debug-log");
        log("Activating '" + options.extensionId + "' extension");
        function log(msg) {
            if (log_output) {
                log_output.append(msg + "\n");
            }
        }
        function error(msg) {
            if (log_output) {
                log_output.append("ERR: " + msg + "\n");
            }
        }
        let javaExecutablePath = findJavaExecutable('java');
        if (javaExecutablePath == null) {
            VSCode.window.showErrorMessage("Couldn't locate java in $JAVA_HOME or $PATH");
            return;
        }
        log("Found java exe: " + javaExecutablePath);
        return isJava8(javaExecutablePath).then(eight => {
            if (!eight) {
                VSCode.window.showErrorMessage('Java-based Language Server requires Java 8 (using ' + javaExecutablePath + ')');
                return;
            }
            log("isJavaEight => true");
            function createServer() {
                return new Promise((resolve, reject) => {
                    PortFinder.getPort((err, port) => {
                        Net.createServer(socket => {
                            log('Child process connected on port ' + port);
                            resolve({
                                reader: socket,
                                writer: socket
                            });
                        }).listen(port, () => {
                            let options = {
                                cwd: VSCode.workspace.rootPath
                            };
                            let child;
                            let args = [
                                '-Dserver.port=' + port,
                                '-jar',
                                fatJarFile,
                            ];
                            if (jvmHeap) {
                                args.unshift("-Xmx" + jvmHeap);
                            }
                            if (DEBUG) {
                                args.unshift(DEBUG_ARG);
                            }
                            log("CMD = " + javaExecutablePath + ' ' + args.join(' '));
                            // Start the child java process
                            child = ChildProcess.execFile(javaExecutablePath, args, options);
                            child.stdout.on('data', (data) => {
                                log("" + data);
                            });
                            child.stderr.on('data', (data) => {
                                error("" + data);
                            });
                        });
                    });
                });
            }
            return setupLanguageClient(context, createServer, options);
        });
    }
}
exports.activate = activate;
function connectToLS(context, options) {
    let connectionInfo = {
        port: 5007
    };
    let serverOptions = () => {
        let socket = Net.connect(connectionInfo);
        let result = {
            writer: socket,
            reader: socket
        };
        return Promise.resolve(result);
    };
    return setupLanguageClient(context, serverOptions, options);
}
function setupLanguageClient(context, createServer, options) {
    // Create the language client and start the client.
    let client = new vscode_languageclient_1.LanguageClient(options.extensionId, options.extensionId, createServer, options.clientOptions);
    if (options.TRACE) {
        client.trace = vscode_jsonrpc_1.Trace.Verbose;
    }
    let progressNotification = new vscode_jsonrpc_1.NotificationType("sts/progress");
    let moveCursorRequest = new vscode_languageclient_1.RequestType("sts/moveCursor");
    let disposable = client.start();
    let progressService = new ProgressService();
    context.subscriptions.push(disposable);
    context.subscriptions.push(progressService);
    return client.onReady().then(() => {
        client.onNotification(progressNotification, (params) => {
            progressService.handle(params);
        });
        client.onRequest(moveCursorRequest, (params) => {
            let editors = VSCode.window.visibleTextEditors;
            for (let editor of editors) {
                if (editor.document.uri.toString() == params.uri) {
                    let cursor = p2c.asPosition(params.position);
                    let selection = new VSCode.Selection(cursor, cursor);
                    editor.selections = [selection];
                }
            }
            return { applied: true };
        });
        return client;
    });
}
function isJava8(javaExecutablePath) {
    return new Promise((resolve, reject) => {
        let result = ChildProcess.execFile(javaExecutablePath, ['-version'], {}, (error, stdout, stderr) => {
            let eight = stderr.indexOf('1.8') >= 0;
            resolve(eight);
        });
    });
}
function findJavaExecutable(binname) {
    binname = correctBinname(binname);
    // First search each JAVA_HOME bin folder
    if (process.env['JAVA_HOME']) {
        let workspaces = process.env['JAVA_HOME'].split(Path.delimiter);
        for (let i = 0; i < workspaces.length; i++) {
            let binpath = Path.join(workspaces[i], 'bin', binname);
            if (FS.existsSync(binpath)) {
                return binpath;
            }
        }
    }
    // Then search PATH parts
    if (process.env['PATH']) {
        let pathparts = process.env['PATH'].split(Path.delimiter);
        for (let i = 0; i < pathparts.length; i++) {
            let binpath = Path.join(pathparts[i], binname);
            if (FS.existsSync(binpath)) {
                return binpath;
            }
        }
    }
    // Else return the binary name directly (this will likely always fail downstream) 
    return null;
}
function correctBinname(binname) {
    if (process.platform === 'win32')
        return binname + '.exe';
    else
        return binname;
}
class ProgressService {
    constructor() {
        this.status = new Map();
    }
    handle(params) {
        let oldMessage = this.status.get(params.id);
        if (oldMessage) {
            oldMessage.dispose();
        }
        if (params.statusMsg) {
            let newMessage = vscode_1.window.setStatusBarMessage(params.statusMsg);
            this.status.set(params.id, newMessage);
        }
    }
    dispose() {
        if (this.status) {
            for (let d of this.status.values()) {
                d.dispose();
            }
        }
        this.status = null;
    }
}
//# sourceMappingURL=launch-util.js.map